:py:mod:`sns_toolbox.simulate.backends`
=======================================

.. py:module:: sns_toolbox.simulate.backends

.. autoapi-nested-parse::

   Simulation backends for nonspiking networks. Each of these are python-based, and are constructed using a Nonspiking
   Network. They can then be run for a step, with the inputs being a vector of neural states and applied currents and the
   output being the next step of neural states.
   William Nourse
   August 31, 2021
   I've heard that you're a low-down Yankee liar



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   sns_toolbox.simulate.backends.Backend
   sns_toolbox.simulate.backends.__SNS_Numpy_Full__
   sns_toolbox.simulate.backends.__SNS_Numpy_No_Delay__
   sns_toolbox.simulate.backends.__SNS_Numpy_Non_Spiking__
   sns_toolbox.simulate.backends.__SNS_Torch_Full__
   sns_toolbox.simulate.backends.__SNS_Torch_No_Delay__
   sns_toolbox.simulate.backends.__SNS_Torch_Non_Spiking__
   sns_toolbox.simulate.backends.__SNS_Sparse_Full__
   sns_toolbox.simulate.backends.__SNS_Sparse_No_Delay__
   sns_toolbox.simulate.backends.__SNS_Sparse_Non_Spiking__
   sns_toolbox.simulate.backends.__SNS_Manual_Full__
   sns_toolbox.simulate.backends.__SNS_Manual_No_Delay__
   sns_toolbox.simulate.backends.__SNS_Manual_Non_Spiking__



Functions
~~~~~~~~~

.. autoapisummary::

   sns_toolbox.simulate.backends.SNS_Numpy
   sns_toolbox.simulate.backends.SNS_Torch
   sns_toolbox.simulate.backends.SNS_Sparse
   sns_toolbox.simulate.backends.SNS_Manual



.. py:class:: Backend(network: sns_toolbox.design.networks.Network, dt: float = 0.1, debug: bool = False, substeps: int = 1)

   Base-level class for all simulation backends. Each will do the following:
       - Construct a representation of a given network using the desired backend technique
       - Take in (some form of) a vector of input states and applied currents, and compute the result for the next
         timestep

   .. py:method:: __get_net_params__(self) -> None


   .. py:method:: __initialize_vectors_and_matrices__(self) -> None
      :abstractmethod:

      Initialize all of the vectors and matrices needed for all of the neural states and parameters. That includes the
      following: U, ULast, Spikes, Cm, Gm, Ibias, Theta0, Theta, ThetaLast, m, TauTheta.
      :return:    None


   .. py:method:: __set_neurons__(self) -> None
      :abstractmethod:

      Iterate over all populations in the network, and set the corresponding neural parameters for each neuron in the
      network: Cm, Gm, Ibias, ULast, U, Theta0, ThetaLast, Theta, TauTheta, m.
      :return:


   .. py:method:: __set_inputs__(self) -> None
      :abstractmethod:

      Build the input connection matrix, and apply linear mapping coefficients.
      :return:    None


   .. py:method:: __set_connections__(self) -> None
      :abstractmethod:

      Build the synaptic parameter matrices. Interpret connectivity patterns between populations into individual
      synapses.
      :return: None


   .. py:method:: __calculate_time_factors__(self) -> None
      :abstractmethod:

      Precompute the time factors for the membrane voltage, firing threshold, and spiking synapses.
      :return: None


   .. py:method:: __initialize_propagation_delay__(self) -> None
      :abstractmethod:

      Create a buffer sized to store enough spike data for the longest synaptic propagation delay.
      :return: None


   .. py:method:: __set_outputs__(self) -> None
      :abstractmethod:

      Build the output connectivity matrices for voltage and spike monitors and apply linear maps. Generate separate
      output monitors for each neuron in a population.
      :return: None


   .. py:method:: __debug_print__(self) -> None
      :abstractmethod:

      Print the values for every vector/matrix which will be used in the forward computation.
      :return: None


   .. py:method:: forward(self, inputs) -> Any

      Compute the next neural states based on previous neural states
      :param inputs:    Input currents into the network
      :return:          The next neural voltages


   .. py:method:: __forward_pass__(self, inputs) -> Any
      :abstractmethod:

      Compute the next neural states based on previous neural states in the following steps:
      Ulast = U
      ThetaLast = Theta
      MappedInputs = cubic*inputs^3 + quadratic*inputs^2 + linear*inputs + offset
      IApp = InputConnectivity X MappedInputs
      GNon = max(0, min(GMaxNon*ULast/R, GMaxNon))
      GSpike = GSpike * (1-TimeFactorSynapse)
      GSyn = GNon + GSpike
      ISyn = ColSum(GSyn*DelE) - ULast*ColSum(GSyn)
      U = ULast + TimeFactorMembrane*(-Gm*ULast + IBias + ISyn + IApp)
      Theta = ThetaLast + TimeFactorThreshold*(-ThetaLast + Theta0 + m*ULast)
      Spikes = Sign(min(0, Theta - U))
      SpikeBuffer = SpikeBuffer shifted down by 1
      SpikeBuffer[first row] = Spikes
      DelayedSpikeMatrix = SpikeBuffer[BufferSteps, BufferedNeurons]
      GSpike = max(GSpike, -DelayedSpikeMatrix*GMaxSpike)
      U = U * (Spikes + 1)
      Outputs = OutputVoltageConnectivity X U + OutputSpikeConnectivity X (-Spikes)
      MappedOutputs = cubic*Outputs^3 + quadratic*Outputs^2 + linear*Outputs + offset
      :param inputs:    Input currents into the network
      :return:          The next neural voltages



.. py:function:: SNS_Numpy(network: sns_toolbox.design.networks.Network, delay=True, spiking=True, **kwargs)


.. py:class:: __SNS_Numpy_Full__(network: sns_toolbox.design.networks.Network, **kwargs)

   Bases: :py:obj:`Backend`

   Base-level class for all simulation backends. Each will do the following:
       - Construct a representation of a given network using the desired backend technique
       - Take in (some form of) a vector of input states and applied currents, and compute the result for the next
         timestep

   .. py:method:: __initialize_vectors_and_matrices__(self) -> None

      Initialize all of the vectors and matrices needed for all of the neural states and parameters. That includes the
      following: U, ULast, Spikes, Cm, Gm, Ibias, Theta0, Theta, ThetaLast, m, TauTheta.
      :return:    None


   .. py:method:: __set_neurons__(self) -> None

      Iterate over all populations in the network, and set the corresponding neural parameters for each neuron in the
      network: Cm, Gm, Ibias, ULast, U, Theta0, ThetaLast, Theta, TauTheta, m.
      :return:


   .. py:method:: __set_inputs__(self) -> None

      Build the input connection matrix, and apply linear mapping coefficients.
      :return:    None


   .. py:method:: __set_connections__(self) -> None

      Build the synaptic parameter matrices. Interpret connectivity patterns between populations into individual
      synapses.
      :return: None


   .. py:method:: __calculate_time_factors__(self) -> None

      Precompute the time factors for the membrane voltage, firing threshold, and spiking synapses.
      :return: None


   .. py:method:: __initialize_propagation_delay__(self) -> None

      Create a buffer sized to store enough spike data for the longest synaptic propagation delay.
      :return: None


   .. py:method:: __set_outputs__(self) -> None

      Build the output connectivity matrices for voltage and spike monitors and apply linear maps. Generate separate
      output monitors for each neuron in a population.
      :return: None


   .. py:method:: __debug_print__(self) -> None

      Print the values for every vector/matrix which will be used in the forward computation.
      :return: None


   .. py:method:: __forward_pass__(self, inputs) -> Any

      Compute the next neural states based on previous neural states in the following steps:
      Ulast = U
      ThetaLast = Theta
      MappedInputs = cubic*inputs^3 + quadratic*inputs^2 + linear*inputs + offset
      IApp = InputConnectivity X MappedInputs
      GNon = max(0, min(GMaxNon*ULast/R, GMaxNon))
      GSpike = GSpike * (1-TimeFactorSynapse)
      GSyn = GNon + GSpike
      ISyn = ColSum(GSyn*DelE) - ULast*ColSum(GSyn)
      U = ULast + TimeFactorMembrane*(-Gm*ULast + IBias + ISyn + IApp)
      Theta = ThetaLast + TimeFactorThreshold*(-ThetaLast + Theta0 + m*ULast)
      Spikes = Sign(min(0, Theta - U))
      SpikeBuffer = SpikeBuffer shifted down by 1
      SpikeBuffer[first row] = Spikes
      DelayedSpikeMatrix = SpikeBuffer[BufferSteps, BufferedNeurons]
      GSpike = max(GSpike, -DelayedSpikeMatrix*GMaxSpike)
      U = U * (Spikes + 1)
      Outputs = OutputVoltageConnectivity X U + OutputSpikeConnectivity X (-Spikes)
      MappedOutputs = cubic*Outputs^3 + quadratic*Outputs^2 + linear*Outputs + offset
      :param inputs:    Input currents into the network
      :return:          The next neural voltages



.. py:class:: __SNS_Numpy_No_Delay__(network: sns_toolbox.design.networks.Network, **kwargs)

   Bases: :py:obj:`__SNS_Numpy_Full__`

   Base-level class for all simulation backends. Each will do the following:
       - Construct a representation of a given network using the desired backend technique
       - Take in (some form of) a vector of input states and applied currents, and compute the result for the next
         timestep

   .. py:method:: __initialize_vectors_and_matrices__(self) -> None

      Initialize all of the vectors and matrices needed for all of the neural states and parameters. That includes the
      following: U, ULast, Spikes, Cm, Gm, Ibias, Theta0, Theta, ThetaLast, m, TauTheta.
      :return:    None


   .. py:method:: __set_connections__(self) -> None

      Build the synaptic parameter matrices. Interpret connectivity patterns between populations into individual
      synapses.
      :return: None


   .. py:method:: __initialize_propagation_delay__(self) -> None

      Create a buffer sized to store enough spike data for the longest synaptic propagation delay.
      :return: None


   .. py:method:: __forward_pass__(self, inputs) -> Any

      Compute the next neural states based on previous neural states in the following steps:
      Ulast = U
      ThetaLast = Theta
      MappedInputs = cubic*inputs^3 + quadratic*inputs^2 + linear*inputs + offset
      IApp = InputConnectivity X MappedInputs
      GNon = max(0, min(GMaxNon*ULast/R, GMaxNon))
      GSpike = GSpike * (1-TimeFactorSynapse)
      GSyn = GNon + GSpike
      ISyn = ColSum(GSyn*DelE) - ULast*ColSum(GSyn)
      U = ULast + TimeFactorMembrane*(-Gm*ULast + IBias + ISyn + IApp)
      Theta = ThetaLast + TimeFactorThreshold*(-ThetaLast + Theta0 + m*ULast)
      Spikes = Sign(min(0, Theta - U))
      SpikeBuffer = SpikeBuffer shifted down by 1
      SpikeBuffer[first row] = Spikes
      DelayedSpikeMatrix = SpikeBuffer[BufferSteps, BufferedNeurons]
      GSpike = max(GSpike, -DelayedSpikeMatrix*GMaxSpike)
      U = U * (Spikes + 1)
      Outputs = OutputVoltageConnectivity X U + OutputSpikeConnectivity X (-Spikes)
      MappedOutputs = cubic*Outputs^3 + quadratic*Outputs^2 + linear*Outputs + offset
      :param inputs:    Input currents into the network
      :return:          The next neural voltages



.. py:class:: __SNS_Numpy_Non_Spiking__(network: sns_toolbox.design.networks.Network, **kwargs)

   Bases: :py:obj:`__SNS_Numpy_Full__`

   Base-level class for all simulation backends. Each will do the following:
       - Construct a representation of a given network using the desired backend technique
       - Take in (some form of) a vector of input states and applied currents, and compute the result for the next
         timestep

   .. py:method:: __initialize_vectors_and_matrices__(self) -> None

      Initialize all of the vectors and matrices needed for all of the neural states and parameters. That includes the
      following: U, ULast, Spikes, Cm, Gm, Ibias, Theta0, Theta, ThetaLast, m, TauTheta.
      :return:    None


   .. py:method:: __set_neurons__(self) -> None

      Iterate over all populations in the network, and set the corresponding neural parameters for each neuron in the
      network: Cm, Gm, Ibias, ULast, U, Theta0, ThetaLast, Theta, TauTheta, m.
      :return:


   .. py:method:: __set_connections__(self) -> None

      Build the synaptic parameter matrices. Interpret connectivity patterns between populations into individual
      synapses.
      :return: None


   .. py:method:: __calculate_time_factors__(self) -> None

      Precompute the time factors for the membrane voltage, firing threshold, and spiking synapses.
      :return: None


   .. py:method:: __initialize_propagation_delay__(self) -> None

      Create a buffer sized to store enough spike data for the longest synaptic propagation delay.
      :return: None


   .. py:method:: __set_outputs__(self) -> None

      Build the output connectivity matrices for voltage and spike monitors and apply linear maps. Generate separate
      output monitors for each neuron in a population.
      :return: None


   .. py:method:: __debug_print__(self) -> None

      Print the values for every vector/matrix which will be used in the forward computation.
      :return: None


   .. py:method:: __forward_pass__(self, inputs) -> Any

      Compute the next neural states based on previous neural states in the following steps:
      Ulast = U
      ThetaLast = Theta
      MappedInputs = cubic*inputs^3 + quadratic*inputs^2 + linear*inputs + offset
      IApp = InputConnectivity X MappedInputs
      GNon = max(0, min(GMaxNon*ULast/R, GMaxNon))
      GSpike = GSpike * (1-TimeFactorSynapse)
      GSyn = GNon + GSpike
      ISyn = ColSum(GSyn*DelE) - ULast*ColSum(GSyn)
      U = ULast + TimeFactorMembrane*(-Gm*ULast + IBias + ISyn + IApp)
      Theta = ThetaLast + TimeFactorThreshold*(-ThetaLast + Theta0 + m*ULast)
      Spikes = Sign(min(0, Theta - U))
      SpikeBuffer = SpikeBuffer shifted down by 1
      SpikeBuffer[first row] = Spikes
      DelayedSpikeMatrix = SpikeBuffer[BufferSteps, BufferedNeurons]
      GSpike = max(GSpike, -DelayedSpikeMatrix*GMaxSpike)
      U = U * (Spikes + 1)
      Outputs = OutputVoltageConnectivity X U + OutputSpikeConnectivity X (-Spikes)
      MappedOutputs = cubic*Outputs^3 + quadratic*Outputs^2 + linear*Outputs + offset
      :param inputs:    Input currents into the network
      :return:          The next neural voltages



.. py:function:: SNS_Torch(network: sns_toolbox.design.networks.Network, device: str = 'cuda', delay=True, spiking=True, **kwargs)


.. py:class:: __SNS_Torch_Full__(network: sns_toolbox.design.networks.Network, device: str = 'cuda', **kwargs)

   Bases: :py:obj:`Backend`

   Base-level class for all simulation backends. Each will do the following:
       - Construct a representation of a given network using the desired backend technique
       - Take in (some form of) a vector of input states and applied currents, and compute the result for the next
         timestep

   .. py:method:: __initialize_vectors_and_matrices__(self) -> None

      Initialize all of the vectors and matrices needed for all of the neural states and parameters. That includes the
      following: U, ULast, Spikes, Cm, Gm, Ibias, Theta0, Theta, ThetaLast, m, TauTheta.
      :return:    None


   .. py:method:: __set_neurons__(self) -> None

      Iterate over all populations in the network, and set the corresponding neural parameters for each neuron in the
      network: Cm, Gm, Ibias, ULast, U, Theta0, ThetaLast, Theta, TauTheta, m.
      :return:


   .. py:method:: __set_inputs__(self) -> None

      Build the input connection matrix, and apply linear mapping coefficients.
      :return:    None


   .. py:method:: __set_connections__(self) -> None

      Build the synaptic parameter matrices. Interpret connectivity patterns between populations into individual
      synapses.
      :return: None


   .. py:method:: __calculate_time_factors__(self) -> None

      Precompute the time factors for the membrane voltage, firing threshold, and spiking synapses.
      :return: None


   .. py:method:: __initialize_propagation_delay__(self) -> None

      Create a buffer sized to store enough spike data for the longest synaptic propagation delay.
      :return: None


   .. py:method:: __set_outputs__(self) -> None

      Build the output connectivity matrices for voltage and spike monitors and apply linear maps. Generate separate
      output monitors for each neuron in a population.
      :return: None


   .. py:method:: __debug_print__(self) -> None

      Print the values for every vector/matrix which will be used in the forward computation.
      :return: None


   .. py:method:: __forward_pass__(self, inputs) -> Any

      Compute the next neural states based on previous neural states in the following steps:
      Ulast = U
      ThetaLast = Theta
      MappedInputs = cubic*inputs^3 + quadratic*inputs^2 + linear*inputs + offset
      IApp = InputConnectivity X MappedInputs
      GNon = max(0, min(GMaxNon*ULast/R, GMaxNon))
      GSpike = GSpike * (1-TimeFactorSynapse)
      GSyn = GNon + GSpike
      ISyn = ColSum(GSyn*DelE) - ULast*ColSum(GSyn)
      U = ULast + TimeFactorMembrane*(-Gm*ULast + IBias + ISyn + IApp)
      Theta = ThetaLast + TimeFactorThreshold*(-ThetaLast + Theta0 + m*ULast)
      Spikes = Sign(min(0, Theta - U))
      SpikeBuffer = SpikeBuffer shifted down by 1
      SpikeBuffer[first row] = Spikes
      DelayedSpikeMatrix = SpikeBuffer[BufferSteps, BufferedNeurons]
      GSpike = max(GSpike, -DelayedSpikeMatrix*GMaxSpike)
      U = U * (Spikes + 1)
      Outputs = OutputVoltageConnectivity X U + OutputSpikeConnectivity X (-Spikes)
      MappedOutputs = cubic*Outputs^3 + quadratic*Outputs^2 + linear*Outputs + offset
      :param inputs:    Input currents into the network
      :return:          The next neural voltages



.. py:class:: __SNS_Torch_No_Delay__(network: sns_toolbox.design.networks.Network, device: str = 'cuda', **kwargs)

   Bases: :py:obj:`__SNS_Torch_Full__`

   Base-level class for all simulation backends. Each will do the following:
       - Construct a representation of a given network using the desired backend technique
       - Take in (some form of) a vector of input states and applied currents, and compute the result for the next
         timestep

   .. py:method:: __initialize_vectors_and_matrices__(self) -> None

      Initialize all of the vectors and matrices needed for all of the neural states and parameters. That includes the
      following: U, ULast, Spikes, Cm, Gm, Ibias, Theta0, Theta, ThetaLast, m, TauTheta.
      :return:    None


   .. py:method:: __set_connections__(self) -> None

      Build the synaptic parameter matrices. Interpret connectivity patterns between populations into individual
      synapses.
      :return: None


   .. py:method:: __initialize_propagation_delay__(self) -> None

      Create a buffer sized to store enough spike data for the longest synaptic propagation delay.
      :return: None


   .. py:method:: __forward_pass__(self, inputs) -> Any

      Compute the next neural states based on previous neural states in the following steps:
      Ulast = U
      ThetaLast = Theta
      MappedInputs = cubic*inputs^3 + quadratic*inputs^2 + linear*inputs + offset
      IApp = InputConnectivity X MappedInputs
      GNon = max(0, min(GMaxNon*ULast/R, GMaxNon))
      GSpike = GSpike * (1-TimeFactorSynapse)
      GSyn = GNon + GSpike
      ISyn = ColSum(GSyn*DelE) - ULast*ColSum(GSyn)
      U = ULast + TimeFactorMembrane*(-Gm*ULast + IBias + ISyn + IApp)
      Theta = ThetaLast + TimeFactorThreshold*(-ThetaLast + Theta0 + m*ULast)
      Spikes = Sign(min(0, Theta - U))
      SpikeBuffer = SpikeBuffer shifted down by 1
      SpikeBuffer[first row] = Spikes
      DelayedSpikeMatrix = SpikeBuffer[BufferSteps, BufferedNeurons]
      GSpike = max(GSpike, -DelayedSpikeMatrix*GMaxSpike)
      U = U * (Spikes + 1)
      Outputs = OutputVoltageConnectivity X U + OutputSpikeConnectivity X (-Spikes)
      MappedOutputs = cubic*Outputs^3 + quadratic*Outputs^2 + linear*Outputs + offset
      :param inputs:    Input currents into the network
      :return:          The next neural voltages



.. py:class:: __SNS_Torch_Non_Spiking__(network: sns_toolbox.design.networks.Network, device: str = 'cuda', **kwargs)

   Bases: :py:obj:`__SNS_Torch_Full__`

   Base-level class for all simulation backends. Each will do the following:
       - Construct a representation of a given network using the desired backend technique
       - Take in (some form of) a vector of input states and applied currents, and compute the result for the next
         timestep

   .. py:method:: __initialize_vectors_and_matrices__(self) -> None

      Initialize all of the vectors and matrices needed for all of the neural states and parameters. That includes the
      following: U, ULast, Spikes, Cm, Gm, Ibias, Theta0, Theta, ThetaLast, m, TauTheta.
      :return:    None


   .. py:method:: __set_neurons__(self) -> None

      Iterate over all populations in the network, and set the corresponding neural parameters for each neuron in the
      network: Cm, Gm, Ibias, ULast, U, Theta0, ThetaLast, Theta, TauTheta, m.
      :return:


   .. py:method:: __set_connections__(self) -> None

      Build the synaptic parameter matrices. Interpret connectivity patterns between populations into individual
      synapses.
      :return: None


   .. py:method:: __calculate_time_factors__(self) -> None

      Precompute the time factors for the membrane voltage, firing threshold, and spiking synapses.
      :return: None


   .. py:method:: __initialize_propagation_delay__(self) -> None

      Create a buffer sized to store enough spike data for the longest synaptic propagation delay.
      :return: None


   .. py:method:: __set_outputs__(self) -> None

      Build the output connectivity matrices for voltage and spike monitors and apply linear maps. Generate separate
      output monitors for each neuron in a population.
      :return: None


   .. py:method:: __debug_print__(self) -> None

      Print the values for every vector/matrix which will be used in the forward computation.
      :return: None


   .. py:method:: __forward_pass__(self, inputs) -> Any

      Compute the next neural states based on previous neural states in the following steps:
      Ulast = U
      ThetaLast = Theta
      MappedInputs = cubic*inputs^3 + quadratic*inputs^2 + linear*inputs + offset
      IApp = InputConnectivity X MappedInputs
      GNon = max(0, min(GMaxNon*ULast/R, GMaxNon))
      GSpike = GSpike * (1-TimeFactorSynapse)
      GSyn = GNon + GSpike
      ISyn = ColSum(GSyn*DelE) - ULast*ColSum(GSyn)
      U = ULast + TimeFactorMembrane*(-Gm*ULast + IBias + ISyn + IApp)
      Theta = ThetaLast + TimeFactorThreshold*(-ThetaLast + Theta0 + m*ULast)
      Spikes = Sign(min(0, Theta - U))
      SpikeBuffer = SpikeBuffer shifted down by 1
      SpikeBuffer[first row] = Spikes
      DelayedSpikeMatrix = SpikeBuffer[BufferSteps, BufferedNeurons]
      GSpike = max(GSpike, -DelayedSpikeMatrix*GMaxSpike)
      U = U * (Spikes + 1)
      Outputs = OutputVoltageConnectivity X U + OutputSpikeConnectivity X (-Spikes)
      MappedOutputs = cubic*Outputs^3 + quadratic*Outputs^2 + linear*Outputs + offset
      :param inputs:    Input currents into the network
      :return:          The next neural voltages



.. py:function:: SNS_Sparse(network: sns_toolbox.design.networks.Network, device: str = 'cuda', delay=True, spiking=True, **kwargs)


.. py:class:: __SNS_Sparse_Full__(network: sns_toolbox.design.networks.Network, device: str = 'cuda', **kwargs)

   Bases: :py:obj:`Backend`

   Base-level class for all simulation backends. Each will do the following:
       - Construct a representation of a given network using the desired backend technique
       - Take in (some form of) a vector of input states and applied currents, and compute the result for the next
         timestep

   .. py:method:: __initialize_vectors_and_matrices__(self) -> None

      Initialize all of the vectors and matrices needed for all of the neural states and parameters. That includes the
      following: U, ULast, Spikes, Cm, Gm, Ibias, Theta0, Theta, ThetaLast, m, TauTheta.
      :return:    None


   .. py:method:: __set_neurons__(self) -> None

      Iterate over all populations in the network, and set the corresponding neural parameters for each neuron in the
      network: Cm, Gm, Ibias, ULast, U, Theta0, ThetaLast, Theta, TauTheta, m.
      :return:


   .. py:method:: __set_inputs__(self) -> None

      Build the input connection matrix, and apply linear mapping coefficients.
      :return:    None


   .. py:method:: __set_connections__(self) -> None

      Build the synaptic parameter matrices. Interpret connectivity patterns between populations into individual
      synapses.
      :return: None


   .. py:method:: __calculate_time_factors__(self) -> None

      Precompute the time factors for the membrane voltage, firing threshold, and spiking synapses.
      :return: None


   .. py:method:: __initialize_propagation_delay__(self) -> None

      Create a buffer sized to store enough spike data for the longest synaptic propagation delay.
      :return: None


   .. py:method:: __set_outputs__(self) -> None

      Build the output connectivity matrices for voltage and spike monitors and apply linear maps. Generate separate
      output monitors for each neuron in a population.
      :return: None


   .. py:method:: __debug_print__(self) -> None

      Print the values for every vector/matrix which will be used in the forward computation.
      :return: None


   .. py:method:: __forward_pass__(self, inputs) -> Any

      Compute the next neural states based on previous neural states in the following steps:
      Ulast = U
      ThetaLast = Theta
      MappedInputs = cubic*inputs^3 + quadratic*inputs^2 + linear*inputs + offset
      IApp = InputConnectivity X MappedInputs
      GNon = max(0, min(GMaxNon*ULast/R, GMaxNon))
      GSpike = GSpike * (1-TimeFactorSynapse)
      GSyn = GNon + GSpike
      ISyn = ColSum(GSyn*DelE) - ULast*ColSum(GSyn)
      U = ULast + TimeFactorMembrane*(-Gm*ULast + IBias + ISyn + IApp)
      Theta = ThetaLast + TimeFactorThreshold*(-ThetaLast + Theta0 + m*ULast)
      Spikes = Sign(min(0, Theta - U))
      SpikeBuffer = SpikeBuffer shifted down by 1
      SpikeBuffer[first row] = Spikes
      DelayedSpikeMatrix = SpikeBuffer[BufferSteps, BufferedNeurons]
      GSpike = max(GSpike, -DelayedSpikeMatrix*GMaxSpike)
      U = U * (Spikes + 1)
      Outputs = OutputVoltageConnectivity X U + OutputSpikeConnectivity X (-Spikes)
      MappedOutputs = cubic*Outputs^3 + quadratic*Outputs^2 + linear*Outputs + offset
      :param inputs:    Input currents into the network
      :return:          The next neural voltages



.. py:class:: __SNS_Sparse_No_Delay__(network: sns_toolbox.design.networks.Network, device: str = 'cuda', **kwargs)

   Bases: :py:obj:`__SNS_Sparse_Full__`

   Base-level class for all simulation backends. Each will do the following:
       - Construct a representation of a given network using the desired backend technique
       - Take in (some form of) a vector of input states and applied currents, and compute the result for the next
         timestep

   .. py:method:: __initialize_vectors_and_matrices__(self) -> None

      Initialize all of the vectors and matrices needed for all of the neural states and parameters. That includes the
      following: U, ULast, Spikes, Cm, Gm, Ibias, Theta0, Theta, ThetaLast, m, TauTheta.
      :return:    None


   .. py:method:: __set_connections__(self) -> None

      Build the synaptic parameter matrices. Interpret connectivity patterns between populations into individual
      synapses.
      :return: None


   .. py:method:: __initialize_propagation_delay__(self) -> None

      Create a buffer sized to store enough spike data for the longest synaptic propagation delay.
      :return: None


   .. py:method:: __forward_pass__(self, inputs) -> Any

      Compute the next neural states based on previous neural states in the following steps:
      Ulast = U
      ThetaLast = Theta
      MappedInputs = cubic*inputs^3 + quadratic*inputs^2 + linear*inputs + offset
      IApp = InputConnectivity X MappedInputs
      GNon = max(0, min(GMaxNon*ULast/R, GMaxNon))
      GSpike = GSpike * (1-TimeFactorSynapse)
      GSyn = GNon + GSpike
      ISyn = ColSum(GSyn*DelE) - ULast*ColSum(GSyn)
      U = ULast + TimeFactorMembrane*(-Gm*ULast + IBias + ISyn + IApp)
      Theta = ThetaLast + TimeFactorThreshold*(-ThetaLast + Theta0 + m*ULast)
      Spikes = Sign(min(0, Theta - U))
      SpikeBuffer = SpikeBuffer shifted down by 1
      SpikeBuffer[first row] = Spikes
      DelayedSpikeMatrix = SpikeBuffer[BufferSteps, BufferedNeurons]
      GSpike = max(GSpike, -DelayedSpikeMatrix*GMaxSpike)
      U = U * (Spikes + 1)
      Outputs = OutputVoltageConnectivity X U + OutputSpikeConnectivity X (-Spikes)
      MappedOutputs = cubic*Outputs^3 + quadratic*Outputs^2 + linear*Outputs + offset
      :param inputs:    Input currents into the network
      :return:          The next neural voltages



.. py:class:: __SNS_Sparse_Non_Spiking__(network: sns_toolbox.design.networks.Network, device: str = 'cuda', **kwargs)

   Bases: :py:obj:`__SNS_Sparse_Full__`

   Base-level class for all simulation backends. Each will do the following:
       - Construct a representation of a given network using the desired backend technique
       - Take in (some form of) a vector of input states and applied currents, and compute the result for the next
         timestep

   .. py:method:: __initialize_vectors_and_matrices__(self) -> None

      Initialize all of the vectors and matrices needed for all of the neural states and parameters. That includes the
      following: U, ULast, Spikes, Cm, Gm, Ibias, Theta0, Theta, ThetaLast, m, TauTheta.
      :return:    None


   .. py:method:: __set_neurons__(self) -> None

      Iterate over all populations in the network, and set the corresponding neural parameters for each neuron in the
      network: Cm, Gm, Ibias, ULast, U, Theta0, ThetaLast, Theta, TauTheta, m.
      :return:


   .. py:method:: __set_connections__(self) -> None

      Build the synaptic parameter matrices. Interpret connectivity patterns between populations into individual
      synapses.
      :return: None


   .. py:method:: __calculate_time_factors__(self) -> None

      Precompute the time factors for the membrane voltage, firing threshold, and spiking synapses.
      :return: None


   .. py:method:: __initialize_propagation_delay__(self) -> None

      Create a buffer sized to store enough spike data for the longest synaptic propagation delay.
      :return: None


   .. py:method:: __set_outputs__(self) -> None

      Build the output connectivity matrices for voltage and spike monitors and apply linear maps. Generate separate
      output monitors for each neuron in a population.
      :return: None


   .. py:method:: __debug_print__(self) -> None

      Print the values for every vector/matrix which will be used in the forward computation.
      :return: None


   .. py:method:: __forward_pass__(self, inputs) -> Any

      Compute the next neural states based on previous neural states in the following steps:
      Ulast = U
      ThetaLast = Theta
      MappedInputs = cubic*inputs^3 + quadratic*inputs^2 + linear*inputs + offset
      IApp = InputConnectivity X MappedInputs
      GNon = max(0, min(GMaxNon*ULast/R, GMaxNon))
      GSpike = GSpike * (1-TimeFactorSynapse)
      GSyn = GNon + GSpike
      ISyn = ColSum(GSyn*DelE) - ULast*ColSum(GSyn)
      U = ULast + TimeFactorMembrane*(-Gm*ULast + IBias + ISyn + IApp)
      Theta = ThetaLast + TimeFactorThreshold*(-ThetaLast + Theta0 + m*ULast)
      Spikes = Sign(min(0, Theta - U))
      SpikeBuffer = SpikeBuffer shifted down by 1
      SpikeBuffer[first row] = Spikes
      DelayedSpikeMatrix = SpikeBuffer[BufferSteps, BufferedNeurons]
      GSpike = max(GSpike, -DelayedSpikeMatrix*GMaxSpike)
      U = U * (Spikes + 1)
      Outputs = OutputVoltageConnectivity X U + OutputSpikeConnectivity X (-Spikes)
      MappedOutputs = cubic*Outputs^3 + quadratic*Outputs^2 + linear*Outputs + offset
      :param inputs:    Input currents into the network
      :return:          The next neural voltages



.. py:function:: SNS_Manual(network: sns_toolbox.design.networks.Network, delay=True, spiking=True, **kwargs)


.. py:class:: __SNS_Manual_Full__(network: sns_toolbox.design.networks.Network, **kwargs)

   Bases: :py:obj:`Backend`

   Base-level class for all simulation backends. Each will do the following:
       - Construct a representation of a given network using the desired backend technique
       - Take in (some form of) a vector of input states and applied currents, and compute the result for the next
         timestep

   .. py:method:: __initialize_vectors_and_matrices__(self) -> None

      Initialize all of the vectors and matrices needed for all of the neural states and parameters. That includes the
      following: U, ULast, Spikes, Cm, Gm, Ibias, Theta0, Theta, ThetaLast, m, TauTheta.
      :return:    None


   .. py:method:: __set_neurons__(self) -> None

      Iterate over all populations in the network, and set the corresponding neural parameters for each neuron in the
      network: Cm, Gm, Ibias, ULast, U, Theta0, ThetaLast, Theta, TauTheta, m.
      :return:


   .. py:method:: __set_inputs__(self) -> None

      Build the input connection matrix, and apply linear mapping coefficients.
      :return:    None


   .. py:method:: __set_connections__(self) -> None

      Build the synaptic parameter matrices. Interpret connectivity patterns between populations into individual
      synapses.
      :return: None


   .. py:method:: __calculate_time_factors__(self) -> None

      Precompute the time factors for the membrane voltage, firing threshold, and spiking synapses.
      :return: None


   .. py:method:: __initialize_propagation_delay__(self) -> None

      Create a buffer sized to store enough spike data for the longest synaptic propagation delay.
      :return: None


   .. py:method:: __set_outputs__(self) -> None

      Build the output connectivity matrices for voltage and spike monitors and apply linear maps. Generate separate
      output monitors for each neuron in a population.
      :return: None


   .. py:method:: __debug_print__(self) -> None

      Print the values for every vector/matrix which will be used in the forward computation.
      :return: None


   .. py:method:: __forward_pass__(self, inputs) -> Any

      Compute the next neural states based on previous neural states in the following steps:
      Ulast = U
      ThetaLast = Theta
      MappedInputs = cubic*inputs^3 + quadratic*inputs^2 + linear*inputs + offset
      IApp = InputConnectivity X MappedInputs
      GNon = max(0, min(GMaxNon*ULast/R, GMaxNon))
      GSpike = GSpike * (1-TimeFactorSynapse)
      GSyn = GNon + GSpike
      ISyn = ColSum(GSyn*DelE) - ULast*ColSum(GSyn)
      U = ULast + TimeFactorMembrane*(-Gm*ULast + IBias + ISyn + IApp)
      Theta = ThetaLast + TimeFactorThreshold*(-ThetaLast + Theta0 + m*ULast)
      Spikes = Sign(min(0, Theta - U))
      SpikeBuffer = SpikeBuffer shifted down by 1
      SpikeBuffer[first row] = Spikes
      DelayedSpikeMatrix = SpikeBuffer[BufferSteps, BufferedNeurons]
      GSpike = max(GSpike, -DelayedSpikeMatrix*GMaxSpike)
      U = U * (Spikes + 1)
      Outputs = OutputVoltageConnectivity X U + OutputSpikeConnectivity X (-Spikes)
      MappedOutputs = cubic*Outputs^3 + quadratic*Outputs^2 + linear*Outputs + offset
      :param inputs:    Input currents into the network
      :return:          The next neural voltages



.. py:class:: __SNS_Manual_No_Delay__(network: sns_toolbox.design.networks.Network, **kwargs)

   Bases: :py:obj:`__SNS_Manual_Full__`

   Base-level class for all simulation backends. Each will do the following:
       - Construct a representation of a given network using the desired backend technique
       - Take in (some form of) a vector of input states and applied currents, and compute the result for the next
         timestep

   .. py:method:: __set_connections__(self) -> None

      Build the synaptic parameter matrices. Interpret connectivity patterns between populations into individual
      synapses.
      :return: None


   .. py:method:: __forward_pass__(self, inputs) -> Any

      Compute the next neural states based on previous neural states in the following steps:
      Ulast = U
      ThetaLast = Theta
      MappedInputs = cubic*inputs^3 + quadratic*inputs^2 + linear*inputs + offset
      IApp = InputConnectivity X MappedInputs
      GNon = max(0, min(GMaxNon*ULast/R, GMaxNon))
      GSpike = GSpike * (1-TimeFactorSynapse)
      GSyn = GNon + GSpike
      ISyn = ColSum(GSyn*DelE) - ULast*ColSum(GSyn)
      U = ULast + TimeFactorMembrane*(-Gm*ULast + IBias + ISyn + IApp)
      Theta = ThetaLast + TimeFactorThreshold*(-ThetaLast + Theta0 + m*ULast)
      Spikes = Sign(min(0, Theta - U))
      SpikeBuffer = SpikeBuffer shifted down by 1
      SpikeBuffer[first row] = Spikes
      DelayedSpikeMatrix = SpikeBuffer[BufferSteps, BufferedNeurons]
      GSpike = max(GSpike, -DelayedSpikeMatrix*GMaxSpike)
      U = U * (Spikes + 1)
      Outputs = OutputVoltageConnectivity X U + OutputSpikeConnectivity X (-Spikes)
      MappedOutputs = cubic*Outputs^3 + quadratic*Outputs^2 + linear*Outputs + offset
      :param inputs:    Input currents into the network
      :return:          The next neural voltages



.. py:class:: __SNS_Manual_Non_Spiking__(network: sns_toolbox.design.networks.Network, **kwargs)

   Bases: :py:obj:`__SNS_Manual_Full__`

   Base-level class for all simulation backends. Each will do the following:
       - Construct a representation of a given network using the desired backend technique
       - Take in (some form of) a vector of input states and applied currents, and compute the result for the next
         timestep

   .. py:method:: __initialize_vectors_and_matrices__(self) -> None

      Initialize all of the vectors and matrices needed for all of the neural states and parameters. That includes the
      following: U, ULast, Spikes, Cm, Gm, Ibias, Theta0, Theta, ThetaLast, m, TauTheta.
      :return:    None


   .. py:method:: __set_neurons__(self) -> None

      Iterate over all populations in the network, and set the corresponding neural parameters for each neuron in the
      network: Cm, Gm, Ibias, ULast, U, Theta0, ThetaLast, Theta, TauTheta, m.
      :return:


   .. py:method:: __set_connections__(self) -> None

      Build the synaptic parameter matrices. Interpret connectivity patterns between populations into individual
      synapses.
      :return: None


   .. py:method:: __calculate_time_factors__(self) -> None

      Precompute the time factors for the membrane voltage, firing threshold, and spiking synapses.
      :return: None


   .. py:method:: __set_outputs__(self) -> None

      Build the output connectivity matrices for voltage and spike monitors and apply linear maps. Generate separate
      output monitors for each neuron in a population.
      :return: None


   .. py:method:: __debug_print__(self) -> None

      Print the values for every vector/matrix which will be used in the forward computation.
      :return: None


   .. py:method:: __forward_pass__(self, inputs) -> Any

      Compute the next neural states based on previous neural states in the following steps:
      Ulast = U
      ThetaLast = Theta
      MappedInputs = cubic*inputs^3 + quadratic*inputs^2 + linear*inputs + offset
      IApp = InputConnectivity X MappedInputs
      GNon = max(0, min(GMaxNon*ULast/R, GMaxNon))
      GSpike = GSpike * (1-TimeFactorSynapse)
      GSyn = GNon + GSpike
      ISyn = ColSum(GSyn*DelE) - ULast*ColSum(GSyn)
      U = ULast + TimeFactorMembrane*(-Gm*ULast + IBias + ISyn + IApp)
      Theta = ThetaLast + TimeFactorThreshold*(-ThetaLast + Theta0 + m*ULast)
      Spikes = Sign(min(0, Theta - U))
      SpikeBuffer = SpikeBuffer shifted down by 1
      SpikeBuffer[first row] = Spikes
      DelayedSpikeMatrix = SpikeBuffer[BufferSteps, BufferedNeurons]
      GSpike = max(GSpike, -DelayedSpikeMatrix*GMaxSpike)
      U = U * (Spikes + 1)
      Outputs = OutputVoltageConnectivity X U + OutputSpikeConnectivity X (-Spikes)
      MappedOutputs = cubic*Outputs^3 + quadratic*Outputs^2 + linear*Outputs + offset
      :param inputs:    Input currents into the network
      :return:          The next neural voltages



