:py:mod:`sns_toolbox.simulate.backends`
=======================================

.. py:module:: sns_toolbox.simulate.backends

.. autoapi-nested-parse::

   Simulation backends for nonspiking networks. Each of these are python-based, and are constructed using a Nonspiking
   Network. They can then be run for a step, with the inputs being a vector of neural states and applied currents and the
   output being the next step of neural states.
   William Nourse
   August 31, 2021
   I've heard that you're a low-down Yankee liar



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   sns_toolbox.simulate.backends.Backend



Functions
~~~~~~~~~

.. autoapisummary::

   sns_toolbox.simulate.backends.SNS_Numpy
   sns_toolbox.simulate.backends.SNS_Torch
   sns_toolbox.simulate.backends.SNS_Sparse
   sns_toolbox.simulate.backends.SNS_Manual



.. py:class:: Backend(network: sns_toolbox.design.networks.Network, dt: float = 0.1, debug: bool = False, substeps: int = 1)

   Base-level class for all simulation backends. Each will do the following:
       - Construct a representation of a given network using the desired backend technique
       - Take in (some form of) a vector of input states and applied currents, and compute the result for the next
         timestep

   .. py:method:: forward(self, inputs) -> Any

      Compute the next neural states based on previous neural states
      :param inputs:    Input currents into the network
      :return:          The next neural voltages



.. py:function:: SNS_Numpy(network: sns_toolbox.design.networks.Network, delay=True, spiking=True, **kwargs)


.. py:function:: SNS_Torch(network: sns_toolbox.design.networks.Network, device: str = 'cuda', delay=True, spiking=True, **kwargs)


.. py:function:: SNS_Sparse(network: sns_toolbox.design.networks.Network, device: str = 'cuda', delay=True, spiking=True, **kwargs)


.. py:function:: SNS_Manual(network: sns_toolbox.design.networks.Network, delay=True, spiking=True, **kwargs)


